我明白了。之前的修复只在 `toggleListening` 内部清除了文本，但这个函数是在点击按钮时才调用的。对于“长按自动进入”的场景，流程是：
`showImportModal` (true) -> `useEffect` (300ms delay) -> `toggleListening`。

在这个过程中，`blur` 逻辑之前被移除了，所以键盘可能又弹出来了。

**修复方案：**

1.  **恢复并优化 `blur` 逻辑**：
    之前移除 `blur` 是因为怕打断 iOS 录音。现在我们可以把 `blur` 操作放在**录音开始之前**，或者只针对 `textarea` 进行 blur，而不是 `document.activeElement`。
    更安全的方法是：在 `useEffect` 中，当 `showImportModal` 为 true 且 `autoStartVoice` 为 true 时，显式调用 `document.body.focus()` 或让所有 input 失焦，**但必须在录音开始之前完成**。

2.  **强制收起键盘**：
    在 `useEffect` 中，当检测到是自动开始语音 (`autoStartVoice` is true) 时，立即执行 `blur`。此时录音还没开始（有 300ms 延迟），所以不会打断录音。

3.  **代码位置**：
    在 `components/AddRecord.tsx` 的 `useEffect` (line 118) 中。

**计划修改**：
```typescript
        if (autoStartVoice) {
            // Re-introduce blur logic but ensure it happens BEFORE recording starts
            // to prevent keyboard from popping up
            if (document.activeElement instanceof HTMLElement) {
                document.activeElement.blur();
            }

            // Small delay to ensure modal is ready and UI is stable
            const timer = setTimeout(() => {
                toggleListening();
                setAutoStartVoice(false);
            }, 300);
            return () => clearTimeout(timer);
        }
```

**关于你提到的“进入后，把键盘收起来，再点击录音按钮，倒是不会调出键盘了”**：
这是因为 `readOnly` 属性在生效。问题在于**刚进入那一瞬间**，焦点可能还停留在之前的元素上，或者系统自动聚焦了新的 input。我们需要主动打断这个聚焦过程。

**确认方案**：恢复 `document.activeElement.blur()`，但确保它在 `toggleListening` 之前执行。